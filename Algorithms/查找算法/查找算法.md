## 查找算法

1.排序算法的介绍
```text
常用的查找有四种:
  1) 顺序(线性)查找
  2) 二分查找/折半查找
  3) 插值查找
  4) 斐波那契查找
```
### 顺序(线性)查找
```text
对所给的数组进行遍历逐一比对，找到目标元素则进行返回对应的下标，找不到则返回-1
```

### 二分查找/折半查找
```text
针对有序数组进行查找，采用中间指针分递归和非递归两种实现方式
```

### 插值查找
```text
插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。其实也就是下图中的mid索引的公式优化
1) 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.
2) 关键字分布不均匀的情况下，该方法不一定比折半查找要好
```
![image](https://github.com/Tandoy/DataStructures-and-Algorithms/blob/master/Algorithms/images/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE.PNG)

### 斐波那契查找(黄金分割法)
```text
1.斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 }发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618
2.斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示
3.对 F(k-1)-1 的理解：
  1) 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：
     只要顺序表的长度为F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1
  2) 类似的，每一子段也可以用相同的方式分割
  3) 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至 F[k]-1。这里的k值只要能使得 F[k]-1 恰好大于或等于 n 即可，由以下代码得到,顺序表长度增加后，新增的位置（从 n+1 到 F[k]-1 位置），都赋为n位置的值即可。
```
![image](https://github.com/Tandoy/DataStructures-and-Algorithms/blob/master/Algorithms/images/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE.PNG)